* 기록하는 공간 *
Program.java 생성
class Program {} public class Program2 {} / 컴파일 에러
public class Program {} class Program2 {} / OK
자바에는 클래스 앞 접근제어자가 붙으면 그 클래스 이름은 *파일명과 동일* 해야 합니다.

/* this & super's Differences
    *  Super > 자손클래스에서 상속받은 맴버를 참조할때 사용됨! / 상속받은 맴버와 자신의 맴버 이름이 같을때! / 부모생성자를 호출할때!
    *  This > 맴버변수와 지역변수의 이름이 같을 때 this 붙여서 비교한다! | 생성자 주입!
    *  this(), this(Parameter) > 생성자, 같은 클래스의 다른 생성자를 호출할 때 사용한다!
    *  this, super 모두 static(class Method)에서는 사용이 불가능하다. 인스턴스 메서드에서만 사용이 가능하다!
    *  클래스로부터 객체를 생성하는걸 '인스턴스화' 라고 하며, 만들어진 객체를 인스턴스라고 한다!
    *  조상맴버(super)와 자신맴버(this)를 구별할때 사용되는것을 제외하면 근본적으로 같다! */

메서드는 특정 작업을 수행하는 일련의 문장들을 하나로 묶은 것이다.
메서드에 넣을 값과 반환하는 결과만 알면 되는것! println(); sqrt();가 어떻게 작동하는지 몰라도 사용하는데 어려움은 없다.
메서드를 사용하는 이유
높은 재사용성, 중복된 코드의 제거(메소드를 만들어서 호출하기만 하면 됨), 프로그램 구조화 init > print > sort > sortArrayPrint 같이 뼈대를 만들고, 나중에 동작하게 하면 된다.

JVM Memory's Structure
Method Area / Call Stack / Heap
1. Method Area
클래스 파일을 JVM이 읽고 분석하여 클래스에 대한 정보를 메서드 영역에 저장한다. 이 때 그 클래스의 클래스변수도 이 영역에서 생성된다.
2. Heap
인스턴스가 생성되는 공간. 프로그램 실행 중 생성되는 인스턴스는 모두 이곳에 생성된다. 인스턴스 변수들이 생성되는 공간이다.
3. Call Stack or Execution stack or 호출스택
호출스택은 메서드의 작업에 필요한 메모리 공간을 제공한다.
메서드가 호출되면, 호출 스택에 호출된 메서드를 위한 메모리가 할당된다 이 메모리는 메서드가 작업을 수행하는 동안 지역변수들과 연산의 중간결과 등을 저장하는데 사용된다.
메서드가 작업을 마치면 할당된 공간도 반환되어 비어진다.

인스턴스 멤버가 존재하는 시점에 클래스 멤버는 항상 존재하지만, 클래스멤버가 존재하는 시점에 인스턴스 멤버가 존재하지 않을 수도 있다.
하나의 인스턴스 멤버가 존재한다는 것은 인스턴스가 이미 생성되어있다는 것을 의미하며, 즉 다른 인스턴스멤버들도 모두 존재하기 때문에 인스턴스멤버간의 호출에있어서 문제가 될 게 없다.

지역변수는 사용하기 전에 반드시 초기화 해야 한다!

String name = ""; // 문자열 리터럴 생성
String name2 = new String("");  // new 연산자를 이용한 문자열 생성
차이는 뭐가있을까? new 연산자를 사용하면 일반 객체들처럼 HEAP 영역에 할당되고, 리터럴을 이용하여 생성하면 String Constant Pool 영역에 할당된다.

getter 은 단순히 값을 반환할때만 사용된다. / setter 은 매개변수에 지정된 값을 검사하여 조건에 맞는 값일 때만 멤버변수의 값을 변경하도록 사용된다.
상속을 통해 확장될 것이 예상된다면 private 대신 protected 사용.

하나의 *.java 에는 public이 단 하나만 존재해야하고, class명과 동일해야한다.


